<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[弹幕聊天]]></title>
    <url>%2F2021%2F09%2F28%2F%E5%BC%B9%E5%B9%95%E8%81%8A%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[用到的技术：html+css+js+websocket：jquery.barrager，bootstrap，tinycolor 等js后端nodejs启动一个websocket服务，代码如下 server.js：//引入nodejs-websocket const ws = require(&#39;nodejs-websocket&#39;); //在线列表 const userList = new Set(); function broadcast(message)&#123; //接受客户端传来的消息 server.connections.forEach((conn) =&gt; &#123; //sendText 服务端发送给客户端方法 let msg = JSON.parse(message); //只有from 没有to 群发 if(!msg.to)&#123; conn.sendText(message); &#125;else&#123; if(msg.to == conn.id)&#123; conn.sendText(message); &#125; &#125; &#125;); &#125; //启动服务 const server = ws.createServer((conn) =&gt; &#123; //接收消息 conn.on(&#39;text&#39;, (str) =&gt; &#123; let msg = JSON.parse(str); //没有to if(!msg.to)&#123; //有新加入 更新列表 if(&quot;join&quot; == msg.type)&#123; userList.add(msg.from); conn.id = msg.from; broadcast(&quot;&#123;\&quot;userList\&quot;:\&quot;&quot;+Array.from(userList).toString()+&quot;\&quot;,\&quot;type\&quot;:\&quot;join\&quot;&#125;&quot;); &#125;if(&quot;leave&quot; == msg.type)&#123; //有离开 更新列表 userList.delete(msg.from); broadcast(&quot;&#123;\&quot;userList\&quot;:\&quot;&quot;+Array.from(userList).toString()+&quot;\&quot;,\&quot;type\&quot;:\&quot;leave\&quot;&#125;&quot;); &#125;else&#123; //有to 广播 broadcast(str); &#125; &#125;else&#123; broadcast(str); &#125; &#125;); //退出 conn.on(&quot;close&quot;, (str) =&gt; &#123; &#125;); conn.on(&#39;error&#39;, (err) =&gt; &#123; //判断错误，假如不判断的话 会断开连接 console.log(&quot;err:&quot;+err); &#125;); &#125;).listen(8001); console.log(&quot;程序已启动，端口8001&quot;); 启动：node server.js 后台启动可以使用 pm2npm install -g pm2 pm2 start pm2 常用命令总结： pm2 logs 显示所有进程日志 pm2 stop all 停止所有进程 pm2 restart all 重启所有进程 pm2 reload all 0秒停机重载进程 (用于 NETWORKED 进程) pm2 stop 0 停止指定的进程 pm2 restart 0 重启指定的进程 pm2 startup 产生 init 脚本 保持进程活着 pm2 web 运行健壮的 computer API endpoint (http://localhost:8001) pm2 delete 0 杀死指定的进程 pm2 delete all 杀死全部进程 运行进程的不同方式： pm2 start app.js -i max 根据有效CPU数目启动最大进程数目 pm2 start app.js -i 3 启动3个进程 pm2 start app.js -x 用fork模式启动 app.js 而不是使用 cluster pm2 start app.js -x -- -a 23 用fork模式启动 app.js 并且传递参数 (-a 23) pm2 start app.js --name serverone 启动一个进程并把它命名为 serverone pm2 stop serverone 停止 serverone 进程 pm2 start app.json 启动进程, 在 app.json里设置选项 pm2 start app.js -i max -- -a 23 在--之后给 app.js 传递参数 pm2 start app.js -i max -e err.log -o out.log 启动 并 生成一个配置文件 前端index.js：//uuid 用于区分自己和他人 if(window.localStorage)&#123; localStorage = window.localStorage; if(!localStorage[&#39;uid&#39;])&#123; localStorage.setItem(&quot;uid&quot;,guid()); &#125; &#125; //连接 webSocket server var wsServer = &#39;ws://localhost:8001&#39;; var websocket= new WebSocket(wsServer); websocket.onclose = function (evt) &#123; console.log(&quot;Disconnected&quot;); &#125;; websocket.onmessage = function (evt) &#123; var data = JSON.parse(evt.data); //系统消息 if(&quot;join&quot; == data.type || &quot;leave&quot; == data.type)&#123; //用户列表 if(data.userList)&#123; $(&quot;#userList&quot;).html(&quot;&quot;); var userList = data.userList.split(&quot;,&quot;); $.each(userList,function(index,item)&#123; if(localStorage[&quot;uid&quot;] == item)&#123; $(&quot;#userList&quot;).append(&quot;&lt;li id=\&quot;&quot;+item+&quot;\&quot;&gt;自己&lt;/lli&gt;&quot;); &#125;else&#123; $(&quot;#userList&quot;).append(&quot;&lt;li id=\&quot;&quot;+item+&quot;\&quot;&gt;&quot;+item+&quot;&lt;/lli&gt;&quot;); &#125; &#125;); var uid = null; //点击用户 发私信 $(&quot;#userList li&quot;).on(&quot;click&quot;,function()&#123; if(uid == $(&quot;#uid&quot;).val())&#123; $(&quot;#uid&quot;).val(&quot;&quot;); &#125;else&#123; uid = $(this).attr(&quot;id&quot;); $(&quot;#uid&quot;).val(uid); &#125; &#125;); &#125; &#125;else&#123; var item = data.msg; //自己发的 if(data.from == localStorage[&quot;uid&quot;])&#123; item.info = &quot;&lt;span style=&#39;border:1px solid white;&#39;&gt;&quot;+item.info+&quot;&lt;/span&gt;&quot;; &#125; $(&#39;body&#39;).barrager(item); //一些彩蛋 if(&quot;抖动&quot; == item.info)&#123; $(&quot;body&quot;).addClass(&quot;shake shake-crazy&quot;); &#125; if(&quot;反转&quot; == item.info || &quot;翻转&quot; == item.info)&#123; var reversal = document.getElementById(&quot;reversal&quot;); reversal.innerHTML = &quot;&lt;style type=&#39;text/css&#39;&gt; html &#123; filter: fliph; /* for ie */&#125; body &#123; transform: rotateY(180deg); /* css3 */ -moz-transform:skew(0deg, 180deg) scale(-1, 1); /* for ff */ -webkit-transform: rotateY(180deg); /* for chrome and safari */ -o-transform:skew(0deg, 180deg) scale(-1, 1); /* for opera */ overflow-x:hidden; &#125;&lt;/style&gt;&quot;; &#125; if(&quot;恢复&quot; == item.info)&#123; $(&quot;body&quot;).removeClass(&quot;shake shake-crazy&quot;); document.getElementById(&quot;reversal&quot;).innerHTML = &quot;&quot;; &#125; &#125; &#125;; websocket.onerror = function (evt, e) &#123; console.log(&#39;Error occured: &#39; + evt.data); &#125;; 其他详细内容请到GitHub中的danmu项目查看。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat重启python发送邮件]]></title>
    <url>%2F2021%2F09%2F28%2Ftomcat%E9%87%8D%E5%90%AFpython%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[restart8080.sh #!/bin/bash ./etc/profile tomcatPath=&quot;/opt/tomcat-8080&quot; binPath=&quot;$tomcatPath/bin&quot; echo &quot;[info][$(date +&#39;%F %H:%M:%S&#39;)]正在监控tomcat，路径：$tomcatPath&quot; pid=`ps -ef | grep tomcat | grep -w $tomcatPath | grep -v &#39;grep&#39; | awk &#39;&#123;print $2&#125;&#39;` if [ -n &quot;$pid&quot; ]; then echo &quot;[info][$(date +&#39;%F %H:%M:%S&#39;)]tomcat进程为：$pid&quot; echo &quot;[info][$(date +&#39;%F %H:%M:%S&#39;)]tomcat已经启动，准备使用shutdown命令关闭...&quot; $binPath&quot;/shutdown.sh&quot; sleep 2 pid=`ps -ef | grep tomcat | grep -w $tomcatPath | grep -v &#39;grep&#39; | awk &#39;&#123;print $2&#125;&#39;` if [ -n &quot;$pid&quot; ]; then echo &quot;[info][$(date +&#39;%F %H:%M:%S&#39;)]使用shutdown命令关闭失败，准备kill进程...&quot; kill -9 $pid echo &quot;[info][$(date +&#39;%F %H:%M:%S&#39;)]kill进程完毕！&quot; sleep 5 else echo &quot;[info][$(date +&#39;%F %H:%M:%S&#39;)]使用shutdown命令关闭成功！&quot; fi else echo &quot;[info][$(date +&#39;%F %H:%M:%S&#39;)]tomcat未启动！&quot; fi echo &quot;[info][$(date +&#39;%F %H:%M:%S&#39;)]准备启动tomcat...&quot; $binPath&quot;/startup.sh&quot; #发送重启邮件 python sendMail.py &quot;tomcat-8080 start at $(date +&#39;%F %H:%M:%S&#39;)&quot; sendMail.py #!/usr/bin/python # -*- coding: UTF-8 -*- import sys import smtplib from email.mime.text import MIMEText from email.header import Header content = sys.argv[1] print(content) #第三方 SMTP 服务 mail_host=&quot;&quot; #设置服务器 mail_user=&quot;&quot; #用户名 mail_pass=&quot;&quot; #口令 sender = &#39;&#39; #发送者名称 receivers = [&#39;&#39;] #接收邮件，可设置为你的QQ邮箱或者其他邮箱，多个逗号隔开 message = MIMEText(content, &#39;plain&#39;, &#39;utf-8&#39;) message[&#39;From&#39;] = Header(&quot;&quot;, &#39;utf-8&#39;) #需修改 message[&#39;To&#39;] = Header(&quot;&quot;, &#39;utf-8&#39;) #需修改 subject = &#39;&#39; #需修改 message[&#39;Subject&#39;] = Header(subject, &#39;utf-8&#39;) try: smtpObj = smtplib.SMTP_SSL() smtpObj.connect(mail_host, 465) #25 为 SMTP 端口号 smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print &quot;邮件发送成功&quot; except smtplib.SMTPException,e: print &quot;Error: 无法发送邮件&quot; print str(e)]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[esp8266 smartConfit]]></title>
    <url>%2F2021%2F01%2F08%2Fesp8266-smartConfit%2F</url>
    <content type="text"><![CDATA[1.开机去读取本机的/wifis.json文件里面的默认wifi去链接2.如果都链接不成功，开启smartConfig3.smartConfig不成功，自己开启wifi，连接后可控制板载led #include &lt;Arduino.h&gt; #include &lt;ArduinoJson.h&gt; #include &lt;ESP8266WiFi.h&gt; #include &lt;ESP8266WiFiMulti.h&gt; #include &lt;ESP8266WebServer.h&gt; #include &lt;FS.h&gt; ESP8266WiFiMulti wifiMulti; DynamicJsonBuffer djb; ESP8266WebServer server(80); void smartConfig() &#123; //切换模式 WiFi.mode(WIFI_STA); Serial.println(&quot;waitting for SmartConfig...&quot;); //开启smartConfig模式 WiFi.beginSmartConfig(); int i = 0; //等待 while (!WiFi.smartConfigDone()) &#123; Serial.print(&quot;.&quot;); delay(1000); i++; //超时 if (i == 30) &#123; Serial.println(&quot;smartConfig timeout 30s&quot;); WiFi.stopSmartConfig(); break; &#125; &#125; //连接到了wifi 打印 写入配置文件 if (wifiMulti.run() == WL_CONNECTED) &#123; Serial.println(&quot;smartConfig success&quot;); Serial.printf(&quot;SSID:%s\r\n&quot;, WiFi.SSID().c_str()); Serial.printf(&quot;PSW:%s\r\n&quot;, WiFi.psk().c_str()); wifiMulti.addAP(WiFi.SSID().c_str(), WiFi.psk().c_str()); writeFile(WiFi.SSID().c_str(), WiFi.psk().c_str()); ledCtrl(&quot;on&quot;); &#125; else &#123; //配置文件里面都不能连接 配置为服务器模式 IPAddress softLocal(192, 168, 1, 1); IPAddress softGateway(192, 168, 1, 1); IPAddress softSubnet(255, 255, 255, 0); WiFi.softAPConfig(softLocal, softGateway, softSubnet); WiFi.softAP(&quot;esp8266-192.168.1.1&quot;, &quot;esp8266666&quot;); startServer(); &#125; &#125; /** 开始页面 */ void homepage() &#123; String filecontend = readFile(&quot;/index.html&quot;); if (filecontend) &#123; server.send(200, &quot;text/html&quot;, filecontend); &#125; else &#123; Serial.println(&quot;index.html is empty&quot;); &#125; &#125; /** * 控制等 */ void pin() &#123; String type = &quot;&quot;; if (server.arg(&quot;light&quot;) == &quot;on&quot;) &#123; type = &quot;on&quot;; &#125; else if (server.arg(&quot;light&quot;) == &quot;off&quot;) &#123; type = &quot;off&quot;; &#125; server.send(200, &quot;text/html&quot;, type); ledCtrl(type); &#125; /** 启动服务 */ void startServer() &#123; server.on(&quot;/&quot;, homepage); server.on(&quot;/pin&quot;, pin); server.begin(); Serial.println(&quot;&quot;); Serial.print(&quot;server start on http://&quot;); Serial.print(WiFi.softAPIP()); Serial.println(&quot;:80&quot;); &#125; /** 把已连接的wifi 写入配置文件 */ void writeFile(String ssid, String pwd) &#123; String fileContent = readFile(&quot;/wifis.json&quot;); if (fileContent != &quot;&quot;) &#123; JsonObject&amp; jo = djb.parse(fileContent); if (jo.containsKey(&quot;wifis&quot;)) &#123; JsonArray&amp; ja = jo[&quot;wifis&quot;]; JsonObject&amp; newObj = djb.createObject(); newObj[&quot;ssid&quot;] = ssid; newObj[&quot;pwd&quot;] = pwd; ja.add(newObj); //jo = djb.createObject(); jo[&quot;wifis&quot;] = ja; File jsonFile = SPIFFS.open(&quot;/wifis.json&quot;, &quot;w+&quot;); if (jsonFile) &#123; jsonFile.print(jo.printTo(jsonFile)); //打印 jo.printTo(Serial); &#125; else &#123; Serial.println(&quot;wifis.json write failed&quot;); &#125; jsonFile.close(); &#125; &#125; &#125; /** 读取文件 返回文件内容 */ String readFile(String filename) &#123; if (SPIFFS.begin()) &#123; Serial.println(&quot;SPIFFS started&quot;); &#125; else &#123; Serial.println(&quot;SPIFFS start failed&quot;); &#125; if (SPIFFS.exists(filename)) &#123; Serial.print(filename); Serial.println(&quot; Found ...&quot;); &#125; else &#123; Serial.print(filename); Serial.println(&quot; Not Found ...&quot;); &#125; File file = SPIFFS.open(filename, &quot;r&quot;); if (!file) &#123; Serial.println(filename + &quot;open failed&quot;); &#125; String fileContent = &quot;&quot;; if (file.size() &gt; 0) &#123; for (int i = 0; i &lt; file.size(); i++) &#123; fileContent += (char)file.read(); &#125; Serial.println(fileContent); &#125; else &#123; Serial.println(filename + &quot; is empty&quot;); &#125; file.close(); return fileContent; &#125; void setup() &#123; Serial.begin(2000000); //板载灯 pinMode(LED_BUILTIN, OUTPUT); Serial.println(); Serial.println(&quot;start to config&quot;); wifiMulti.run(); //判断是否已自动连接到wifi if (wifiMulti.run() == WL_CONNECTED) &#123; Serial.print(&quot;&quot;); Serial.println(&quot;connect success&quot;); Serial.println(&quot;ip:&quot;); Serial.println(WiFi.localIP()); &#125; else if (wifiMulti.run() != WL_CONNECTED) &#123; Serial.println(&quot;not connected&quot;); //先判断wifis.json是否有记录 有 读取 没有 smartConfig String fileContent = readFile(&quot;/wifis.json&quot;); if (fileContent != &quot;&quot;) &#123; WiFi.mode(WIFI_STA); JsonObject&amp; jo = djb.parse(fileContent); if (jo.containsKey(&quot;wifis&quot;)) &#123; JsonArray&amp; ja = jo[&quot;wifis&quot;]; const char* ssid; const char* pwd; for (int i = 0; i &lt; ja.size(); i++) &#123; ssid = ja[i][&quot;ssid&quot;]; pwd = ja[i][&quot;pwd&quot;]; wifiMulti.addAP(ssid, pwd); Serial.println(&quot;connect by wifis.json&quot;); Serial.print(&quot;ssid:&quot;); Serial.println(ssid); Serial.print(&quot;pwd:&quot;); Serial.println(pwd); int j = 0; while (wifiMulti.run() != WL_CONNECTED) &#123; delay(500); j ++; //等待20s if (j == 20) &#123; Serial.print(&quot;connect to &quot;); Serial.print(ssid); Serial.println(&quot; failed:timeout 20s&quot;); break; &#125; &#125; //连接到了wifi 打印ip if (wifiMulti.run() == WL_CONNECTED) &#123; Serial.println(&quot;connect success&quot;); Serial.println(&quot;ip:&quot;); Serial.println(WiFi.localIP()); ledCtrl(&quot;on&quot;); &#125; &#125; &#125; else &#123; Serial.println(&quot;wifis.json is empty&quot;); &#125; &#125; //从配置文件读取失败 开始smartConfig 配置 if (wifiMulti.run() != WL_CONNECTED) &#123; smartConfig(); &#125; &#125; &#125; void ledCtrl(String type) &#123; if (type == &quot;on&quot;) &#123; digitalWrite(LED_BUILTIN, LOW); &#125; else if (type == &quot;off&quot;) &#123; digitalWrite(LED_BUILTIN, HIGH); &#125; &#125; void loop() &#123; //监听客户请求并处理 server.handleClient(); &#125;]]></content>
      <categories>
        <category>mcu</category>
      </categories>
      <tags>
        <tag>esp8266 smartConfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2019%2F10%2F28%2Fmysql%2F</url>
    <content type="text"><![CDATA[1.mysql 按in条件中的字段排序SELECT * FROM 表名 WHERE id in(值) order by field(字段,值); 2.查询按照分组将多条记录转换成单条记录的group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段][Separator &#39;分隔符&#39;]) 查询后字段是有长度的，可以执行以下语句进行查询: show variables like &#39;group_concat_max_len&#39;; 修改的方式有两种： (1).在my.ini [mysql]后面加入 （需重启）： group_concat_max_len = 102400000&#39;; (2).执行以下语句（重启失效）： SET GLOBAL group_concat_max_len = 1024000; 3.This function has none of DETERMINISTIC, NO SQLSET GLOBAL log_bin_trust_function_creators = 1; 4.锁表有关 – 查询是否锁表 SHOW OPEN TABLES WHERE In_use &gt; 0; – 查看所有进程 SHOW PROCESSLIST; SHOW FULL PROCESSLIST; – 杀掉指定mysql连接的进程号 KILL 178; – 拼写多个时间大于x的kill语句 SELECT CONCAT(&#39;kill &#39;, id,&#39;;&#39;) FROM information_schema.PROCESSLIST WHERE time &gt; 100; – 查看正在锁的事务 SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; – 查看等待锁的事务 SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS; – 查看innodb引擎的运行时信息 SHOW engine innodb status; – 查看造成死锁的sql语句，分析索引情况，然后优化sql语句 – 查看服务器状态 SHOW STATUS LIKE &#39;%lock%&#39;; – 查看超时时间： SHOW VARIABLES LIKE &#39;%timeout%&#39;; – 拼写多个被锁的kill语句 select concat(&#39;kill &#39;, id,&#39;;&#39;) from information_schema.processlist where state like &#39;%Locked%&#39;; 5.uuid()CREATE DEFINER=`root`@`%` FUNCTION `getUUID`() RETURNS varchar(50) CHARSET utf8 BEGIN DECLARE uuid varchar(50); select concat(DATE_FORMAT(NOW(),&#39;%Y%m%d%H%i%s&#39;),replace(uuid(),&#39;-&#39;,&#39;&#39;)) from dual INTO uuid; RETURN uuid; END 6.哪些表有大于N条数据USE information_schema; SELECT TABLE_NAME ,TABLE_ROWS FROM TABLES WHERE TABLE_SCHEMA=&#39;库名&#39; AND TABLE_ROWS &gt; N ORDER BY TABLE_ROWS DESC;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql 语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 人脸识别-Haar Cascade]]></title>
    <url>%2F2018%2F01%2F29%2Fpython-%E6%91%84%E5%83%8F%E5%A4%B4%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-Haar-Cascade%2F</url>
    <content type="text"><![CDATA[#-*- coding: UTF-8 -*- import cv2 import numpy as np #打开1号摄像头 cap = cv2.VideoCapture(0) #读取一桢图像，前一个返回值是是否成功，后一个返回值是图像本身 success, frame = cap.read() #设置人脸框的颜色 color = (0,255,0) #定义分类器 face_cascade = cv2.CascadeClassifier(&#39;../config/cv2/haarcascade_frontalface_alt.xml&#39;) while success: success, frame = cap.read() #获得当前桢彩色图像的大小 size = frame.shape[:2] #定义一个与当前桢图像大小相同的的灰度图像矩阵 image = np.zeros(size,dtype=np.float16) #将当前桢图像转换成灰度图像（这里有修改） image = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) #灰度图像进行直方图等距化 cv2.equalizeHist(image, image) #如下三行是设定最小图像的大小 divisor =8 h, w = size #这里加了一个取整函数 minSize = (int(w/divisor), int(h/divisor)) #人脸检测 faces = face_cascade.detectMultiScale( image, scaleFactor=1.1,#表示在前后两次相继的扫描中，搜索窗口的比例系数。默认为1.1即每次搜索窗口依次扩大10%; minNeighbors=3,#表示构成检测目标的相邻矩形的最小个数(默认为3个)。如果组成检测目标的小矩形的个数和小于 min_neighbors - 1 都会被排除。如果min_neighbors 为 0, 则函数不做任何操作就返回所有的被检候选矩形框，这种设定值一般用在用户自定义对检测结果的组合程序上； minSize=minSize ) #如果人脸数组长度大于0 if len(faces) &gt; 0: for face in faces: #对每一个人脸画矩形框 x, y, w, h = face cv2.rectangle(frame, (x, y), (x+w, y+h), color,2) print &#39;有人来了&#39; #显示图像 cv2.imshow(&quot;test&quot;, frame) key = cv2.waitKey(10) c = chr(key &amp; 255) if c in [&#39;q&#39;, &#39;Q&#39;, chr(27)]: break]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Haar Cascade</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2017%2F11%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hexo,终于弄好了！1.安装nodejs2.安装git3.新建文件夹进入sudo npm install -g hexo （切换淘宝镜像npm config set registry https://registry.npm.taobao.org，查看npm config get registry）4.hexo init5.hexo generate（hexo g）6.修改 _config.ymldeploy: type: git repo: https://github.com/fanyushuai/fanyushuai.github.io.git（到gitgub新建repositories） branch: master7.npm install hexo-deployer-git –save 8.hexo deploy9.hexo server 注意：每次部署的步骤，可按以下三步来进行。1.hexo clean2.hexo generate3.hexo deploy一气呵成：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
