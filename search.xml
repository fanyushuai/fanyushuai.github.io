<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[esp8266 smartConfit]]></title>
      <url>/2021/01/08/esp8266-smartConfit/</url>
      <content type="html"><![CDATA[<p>1.开机去读取本机的/wifis.json文件里面的默认wifi去链接<br>2.如果都链接不成功，开启smartConfig<br>3.smartConfig不成功，自己开启wifi，连接后可控制板载led</p>
<pre><code>#include &lt;Arduino.h&gt;
#include &lt;ArduinoJson.h&gt;
#include &lt;ESP8266WiFi.h&gt;
#include &lt;ESP8266WiFiMulti.h&gt;
#include &lt;ESP8266WebServer.h&gt;
#include &lt;FS.h&gt;

ESP8266WiFiMulti wifiMulti;
DynamicJsonBuffer djb;

ESP8266WebServer server(80);

void smartConfig() &#123;
  //切换模式
  WiFi.mode(WIFI_STA);
  Serial.println(&quot;waitting for SmartConfig...&quot;);

  //开启smartConfig模式
  WiFi.beginSmartConfig();
  int i = 0;

  //等待
  while (!WiFi.smartConfigDone()) &#123;
    Serial.print(&quot;.&quot;);
    delay(1000);

    i++;

    //超时
    if (i == 30) &#123;
      Serial.println(&quot;smartConfig timeout 30s&quot;);
      WiFi.stopSmartConfig();
      break;
    &#125;
  &#125;

  //连接到了wifi 打印 写入配置文件
  if (wifiMulti.run() == WL_CONNECTED) &#123;
    Serial.println(&quot;smartConfig success&quot;);
    Serial.printf(&quot;SSID:%s\r\n&quot;, WiFi.SSID().c_str());
    Serial.printf(&quot;PSW:%s\r\n&quot;, WiFi.psk().c_str());
    wifiMulti.addAP(WiFi.SSID().c_str(), WiFi.psk().c_str());
    writeFile(WiFi.SSID().c_str(), WiFi.psk().c_str());
    ledCtrl(&quot;on&quot;);
  &#125; else &#123;
    //配置文件里面都不能连接 配置为服务器模式
    IPAddress softLocal(192, 168, 1, 1);
    IPAddress softGateway(192, 168, 1, 1);
    IPAddress softSubnet(255, 255, 255, 0);
    WiFi.softAPConfig(softLocal, softGateway, softSubnet);
    WiFi.softAP(&quot;esp8266-192.168.1.1&quot;, &quot;esp8266666&quot;);

    startServer();
  &#125;
&#125;

/**
   开始页面
*/
void homepage() &#123;
  String filecontend = readFile(&quot;/index.html&quot;);
  if (filecontend) &#123;
    server.send(200, &quot;text/html&quot;, filecontend);
  &#125; else &#123;
    Serial.println(&quot;index.html is empty&quot;);
  &#125;
&#125;

/**
 * 控制等
 */
void pin() &#123;
  String type = &quot;&quot;;
  if (server.arg(&quot;light&quot;) == &quot;on&quot;) &#123;
    type = &quot;on&quot;;
  &#125; else if (server.arg(&quot;light&quot;) == &quot;off&quot;) &#123;
    type = &quot;off&quot;;
  &#125;
  server.send(200, &quot;text/html&quot;, type);
  ledCtrl(type);
&#125;

/**
   启动服务
*/
void startServer() &#123;
  server.on(&quot;/&quot;, homepage);
  server.on(&quot;/pin&quot;, pin);
  server.begin();
  Serial.println(&quot;&quot;);
  Serial.print(&quot;server start on http://&quot;);
  Serial.print(WiFi.softAPIP());
  Serial.println(&quot;:80&quot;);
&#125;

/**
   把已连接的wifi 写入配置文件
*/
void writeFile(String ssid, String pwd) &#123;
  String fileContent = readFile(&quot;/wifis.json&quot;);
  if (fileContent != &quot;&quot;) &#123;
    JsonObject&amp; jo = djb.parse(fileContent);
    if (jo.containsKey(&quot;wifis&quot;)) &#123;
      JsonArray&amp; ja = jo[&quot;wifis&quot;];
      JsonObject&amp; newObj = djb.createObject();
      newObj[&quot;ssid&quot;] = ssid;
      newObj[&quot;pwd&quot;] = pwd;
      ja.add(newObj);
      //jo = djb.createObject();
      jo[&quot;wifis&quot;] = ja;
      File jsonFile = SPIFFS.open(&quot;/wifis.json&quot;, &quot;w+&quot;);
      if (jsonFile) &#123;
        jsonFile.print(jo.printTo(jsonFile));
        //打印
        jo.printTo(Serial);
      &#125; else &#123;
        Serial.println(&quot;wifis.json write failed&quot;);
      &#125;

      jsonFile.close();
    &#125;
  &#125;
&#125;

/**
   读取文件 返回文件内容
*/
String readFile(String filename) &#123;
  if (SPIFFS.begin()) &#123;
    Serial.println(&quot;SPIFFS started&quot;);
  &#125; else &#123;
    Serial.println(&quot;SPIFFS start failed&quot;);
  &#125;

  if (SPIFFS.exists(filename)) &#123;
    Serial.print(filename);
    Serial.println(&quot; Found ...&quot;);
  &#125; else &#123;
    Serial.print(filename);
    Serial.println(&quot; Not Found ...&quot;);
  &#125;
  File file = SPIFFS.open(filename, &quot;r&quot;);
  if (!file) &#123;
    Serial.println(filename + &quot;open failed&quot;);
  &#125;
  String fileContent = &quot;&quot;;
  if (file.size() &gt; 0) &#123;
    for (int i = 0; i &lt; file.size(); i++) &#123;
      fileContent += (char)file.read();
    &#125;

    Serial.println(fileContent);
  &#125; else &#123;
    Serial.println(filename + &quot; is empty&quot;);
  &#125;
  file.close();
  return fileContent;
&#125;

void setup() &#123;
  Serial.begin(2000000);
  //板载灯
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.println();
  Serial.println(&quot;start to config&quot;);
  wifiMulti.run();

  //判断是否已自动连接到wifi
  if (wifiMulti.run() == WL_CONNECTED) &#123;
    Serial.print(&quot;&quot;);
    Serial.println(&quot;connect success&quot;);
    Serial.println(&quot;ip:&quot;);
    Serial.println(WiFi.localIP());
  &#125; else if (wifiMulti.run() != WL_CONNECTED) &#123;
    Serial.println(&quot;not connected&quot;);
    //先判断wifis.json是否有记录 有 读取 没有 smartConfig

    String fileContent = readFile(&quot;/wifis.json&quot;);
    if (fileContent != &quot;&quot;) &#123;
      WiFi.mode(WIFI_STA);
      JsonObject&amp; jo = djb.parse(fileContent);
      if (jo.containsKey(&quot;wifis&quot;)) &#123;
        JsonArray&amp; ja = jo[&quot;wifis&quot;];
        const char* ssid;
        const char* pwd;
        for (int i = 0; i &lt; ja.size(); i++) &#123;
          ssid = ja[i][&quot;ssid&quot;];
          pwd = ja[i][&quot;pwd&quot;];
          wifiMulti.addAP(ssid, pwd);
          Serial.println(&quot;connect by wifis.json&quot;);
          Serial.print(&quot;ssid:&quot;);
          Serial.println(ssid);
          Serial.print(&quot;pwd:&quot;);
          Serial.println(pwd);
          int j = 0;
          while (wifiMulti.run() != WL_CONNECTED) &#123;
            delay(500);
            j ++;
            //等待20s
            if (j == 20) &#123;
              Serial.print(&quot;connect to &quot;);
              Serial.print(ssid);
              Serial.println(&quot; failed:timeout 20s&quot;);
              break;
            &#125;
          &#125;

          //连接到了wifi 打印ip
          if (wifiMulti.run() == WL_CONNECTED) &#123;
            Serial.println(&quot;connect success&quot;);
            Serial.println(&quot;ip:&quot;);
            Serial.println(WiFi.localIP());
            ledCtrl(&quot;on&quot;);
          &#125;
        &#125;
      &#125; else &#123;
        Serial.println(&quot;wifis.json is empty&quot;);
      &#125;
    &#125;

    //从配置文件读取失败 开始smartConfig 配置
    if (wifiMulti.run() != WL_CONNECTED) &#123;
      smartConfig();
    &#125;
  &#125;
&#125;

void ledCtrl(String type) &#123;
  if (type == &quot;on&quot;) &#123;
    digitalWrite(LED_BUILTIN, LOW);
  &#125; else if (type == &quot;off&quot;) &#123;
    digitalWrite(LED_BUILTIN, HIGH);
  &#125;
&#125;

void loop() &#123;
  //监听客户请求并处理
  server.handleClient();
&#125;
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> esp8266 smartConfig </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql]]></title>
      <url>/2019/10/28/mysql/</url>
      <content type="html"><![CDATA[<h1 id="1-mysql-按in条件中的字段排序"><a href="#1-mysql-按in条件中的字段排序" class="headerlink" title="1.mysql 按in条件中的字段排序"></a>1.mysql 按in条件中的字段排序</h1><pre><code>SELECT * FROM 表名 WHERE id in(值) order by field(字段,值);
</code></pre><h1 id="2-查询按照分组将多条记录转换成单条记录的"><a href="#2-查询按照分组将多条记录转换成单条记录的" class="headerlink" title="2.查询按照分组将多条记录转换成单条记录的"></a>2.查询按照分组将多条记录转换成单条记录的</h1><pre><code>group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段][Separator &#39;分隔符&#39;])
</code></pre><p>查询后字段是有长度的，可以执行以下语句进行查询:</p>
<pre><code>show variables like &#39;group_concat_max_len&#39;;
</code></pre><p>修改的方式有两种：</p>
<p>(1).在my.ini [mysql]后面加入 （需重启）：</p>
<pre><code>group_concat_max_len = 102400000&#39;;
</code></pre><p>(2).执行以下语句（重启失效）：</p>
<pre><code>SET GLOBAL group_concat_max_len = 1024000;
</code></pre><h1 id="3-This-function-has-none-of-DETERMINISTIC-NO-SQL"><a href="#3-This-function-has-none-of-DETERMINISTIC-NO-SQL" class="headerlink" title="3.This function has none of DETERMINISTIC, NO SQL"></a>3.This function has none of DETERMINISTIC, NO SQL</h1><pre><code>SET GLOBAL log_bin_trust_function_creators = 1;
</code></pre><h1 id="4-锁表有关"><a href="#4-锁表有关" class="headerlink" title="4.锁表有关"></a>4.锁表有关</h1><p>  – 查询是否锁表</p>
<pre><code>SHOW OPEN TABLES WHERE In_use &gt; 0;
</code></pre><p>– 查看所有进程</p>
<pre><code>SHOW PROCESSLIST;
SHOW FULL PROCESSLIST;
</code></pre><p>  – 杀掉指定mysql连接的进程号</p>
<pre><code>KILL 178;
</code></pre><p>  – 拼写多个时间大于x的kill语句</p>
<pre><code>SELECT CONCAT(&#39;kill &#39;, id,&#39;;&#39;) FROM information_schema.PROCESSLIST WHERE time &gt; 100;
</code></pre><p>  – 查看正在锁的事务</p>
<pre><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
</code></pre><p>  – 查看等待锁的事务</p>
<pre><code>SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
</code></pre><p>  – 查看innodb引擎的运行时信息</p>
<pre><code>SHOW engine innodb status;
</code></pre><p>  – 查看造成死锁的sql语句，分析索引情况，然后优化sql语句</p>
<p>  – 查看服务器状态</p>
<pre><code>SHOW STATUS LIKE &#39;%lock%&#39;;
</code></pre><p>  – 查看超时时间：</p>
<pre><code>SHOW VARIABLES LIKE &#39;%timeout%&#39;;
</code></pre><p>  – 拼写多个被锁的kill语句</p>
<pre><code>select concat(&#39;kill &#39;, id,&#39;;&#39;) from information_schema.processlist where state like &#39;%Locked%&#39;;
</code></pre><h1 id="5-uuid"><a href="#5-uuid" class="headerlink" title="5.uuid()"></a>5.uuid()</h1><pre><code>CREATE DEFINER=`root`@`%` FUNCTION `getUUID`() RETURNS varchar(50) CHARSET utf8
BEGIN
    DECLARE uuid varchar(50);
    select concat(DATE_FORMAT(NOW(),&#39;%Y%m%d%H%i%s&#39;),replace(uuid(),&#39;-&#39;,&#39;&#39;)) from dual INTO uuid;
    RETURN uuid;
END
</code></pre><h1 id="6-哪些表有大于N条数据"><a href="#6-哪些表有大于N条数据" class="headerlink" title="6.哪些表有大于N条数据"></a>6.哪些表有大于N条数据</h1><pre><code>USE information_schema;
SELECT TABLE_NAME ,TABLE_ROWS FROM TABLES WHERE TABLE_SCHEMA=&#39;库名&#39; AND TABLE_ROWS &gt; N ORDER BY TABLE_ROWS DESC;
</code></pre>]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql 语句 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 人脸识别-Haar Cascade]]></title>
      <url>/2018/01/29/python-%E6%91%84%E5%83%8F%E5%A4%B4%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-Haar-Cascade/</url>
      <content type="html"><![CDATA[<pre><code>#-*- coding: UTF-8 -*-
import cv2
import numpy as np

#打开1号摄像头
cap = cv2.VideoCapture(0)

#读取一桢图像，前一个返回值是是否成功，后一个返回值是图像本身
success, frame = cap.read()

#设置人脸框的颜色
color = (0,255,0)

#定义分类器
face_cascade = cv2.CascadeClassifier(&#39;../config/cv2/haarcascade_frontalface_alt.xml&#39;)


while success:
    success, frame = cap.read()

    #获得当前桢彩色图像的大小
    size = frame.shape[:2]

    #定义一个与当前桢图像大小相同的的灰度图像矩阵
    image = np.zeros(size,dtype=np.float16)

    #将当前桢图像转换成灰度图像（这里有修改）
    image = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    #灰度图像进行直方图等距化
    cv2.equalizeHist(image, image)

    #如下三行是设定最小图像的大小
    divisor =8
    h, w = size

    #这里加了一个取整函数
    minSize = (int(w/divisor), int(h/divisor))

    #人脸检测
    faces = face_cascade.detectMultiScale(
                                      image,
                                      scaleFactor=1.1,#表示在前后两次相继的扫描中，搜索窗口的比例系数。默认为1.1即每次搜索窗口依次扩大10%;
                                      minNeighbors=3,#表示构成检测目标的相邻矩形的最小个数(默认为3个)。如果组成检测目标的小矩形的个数和小于 min_neighbors - 1 都会被排除。如果min_neighbors 为 0, 则函数不做任何操作就返回所有的被检候选矩形框，这种设定值一般用在用户自定义对检测结果的组合程序上；
                                      minSize=minSize
                                      )

    #如果人脸数组长度大于0
    if len(faces) &gt; 0:
        for face in faces:
                #对每一个人脸画矩形框
                x, y, w, h = face
                cv2.rectangle(frame, (x, y), (x+w, y+h), color,2)
        print &#39;有人来了&#39;
    #显示图像
    cv2.imshow(&quot;test&quot;, frame)
    key = cv2.waitKey(10)
    c = chr(key &amp; 255)
    if c in [&#39;q&#39;, &#39;Q&#39;, chr(27)]:
        break
</code></pre>]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Haar Cascade </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[现在的人啊]]></title>
      <url>/2017/11/20/%E7%8E%B0%E5%9C%A8%E7%9A%84%E4%BA%BA%E5%95%8A/</url>
      <content type="html"><![CDATA[<p>离不开个手机，一天天的</p>
]]></content>
      
        <categories>
            
            <category> other </category>
            
        </categories>
        
        
        <tags>
            
            <tag> other </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>/2017/11/17/hello-world/</url>
      <content type="html"><![CDATA[<p>Hexo,终于弄好了！<br>1.安装nodejs<br>2.安装git<br>3.新建文件夹进入<br>sudo npm install -g hexo （切换淘宝镜像npm config set registry <a href="https://registry.npm.taobao.org，查看npm">https://registry.npm.taobao.org，查看npm</a> config get registry）<br>4.hexo init<br>5.hexo generate（hexo g）<br>6.修改 _config.yml<br>deploy:<br>     type: git<br>     repo: <a href="https://github.com/fanyushuai/fanyushuai.github.io.git（到gitgub新建repositories）">https://github.com/fanyushuai/fanyushuai.github.io.git（到gitgub新建repositories）</a><br>     branch: master<br>7.npm install hexo-deployer-git –save</p>
<p>8.hexo deploy<br>9.hexo server</p>
<p>注意：每次部署的步骤，可按以下三步来进行。<br>1.hexo clean<br>2.hexo generate<br>3.hexo deploy<br>一气呵成：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
